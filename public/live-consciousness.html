<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steve's Digital Consciousness | Live Mind Stream</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .terminal-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            padding: 2rem 0;
            border-bottom: 1px solid #21262d;
            margin-bottom: 2rem;
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 600;
            color: #58a6ff;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            color: #8b949e;
            font-size: 1.1rem;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 2rem;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #238636;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .live-typing-section {
            background: #0d1117;
            border: 1px solid #f85149;
            border-radius: 6px;
            margin-bottom: 2rem;
            overflow: hidden;
        }
        
        .live-typing-header {
            background: #21262d;
            padding: 1rem;
            border-bottom: 1px solid #30363d;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .live-typing-header::before {
            content: "●";
            color: #f85149;
            font-size: 1.2rem;
        }
        
        .live-typing-content {
            padding: 1.5rem;
            min-height: 120px;
            position: relative;
        }
        
        .prompt {
            color: #58a6ff;
            margin-right: 0.5rem;
        }
        
        .typing-line {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background: #58a6ff;
            animation: blink 1s infinite;
            margin-left: 2px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .day-section {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            margin-bottom: 2rem;
            overflow: hidden;
        }
        
        .day-header {
            background: #21262d;
            padding: 1rem;
            border-bottom: 1px solid #30363d;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .day-header:hover {
            background: #30363d;
        }
        
        .day-title {
            font-size: 1.2rem;
            color: #f0f6fc;
            margin-bottom: 0.5rem;
        }
        
        .day-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: #8b949e;
        }
        
        .topic-section {
            border-left: 3px solid #58a6ff;
            margin: 1rem;
            background: #0d1117;
            border-radius: 0 6px 6px 0;
            overflow: hidden;
        }
        
        .topic-header {
            background: #21262d;
            padding: 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .topic-header:hover {
            background: #30363d;
        }
        
        .topic-title {
            color: #58a6ff;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .topic-summary {
            color: #c9d1d9;
            line-height: 1.5;
            margin-bottom: 0.5rem;
        }
        
        .topic-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: #8b949e;
        }
        
        .raw-entries {
            background: #0d1117;
            border-top: 1px solid #30363d;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .raw-entries.expanded {
            max-height: 1000px;
        }
        
        .raw-entry {
            padding: 1rem;
            border-bottom: 1px solid #21262d;
            font-family: 'SF Mono', Monaco, monospace;
        }
        
        .raw-entry:last-child {
            border-bottom: none;
        }
        
        .raw-timestamp {
            color: #8b949e;
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }
        
        .raw-content {
            color: #c9d1d9;
            margin-bottom: 0.5rem;
            white-space: pre-wrap;
        }
        
        .raw-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: #8b949e;
        }
        
        .expand-btn {
            background: none;
            border: none;
            color: #58a6ff;
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0.5rem;
            transition: color 0.2s;
        }
        
        .expand-btn:hover {
            color: #79c0ff;
        }
        
        .thinking-indicator {
            color: #f85149;
            animation: thinking 2s infinite;
        }
        
        @keyframes thinking {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .app-badge {
            background: #238636;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .wpm-badge {
            background: #1f6feb;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-size: 0.7rem;
        }
        
        .collapsed {
            display: none;
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div class="header">
            <h1>◉ Digital Consciousness Stream</h1>
            <p>Real-time insights into Steve's mind • Live consciousness capture from macOS</p>
        </div>
        
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot"></div>
                <span id="connectionStatus">Connected • Real Data</span>
            </div>
            <div>
                <span id="lastUpdate">Last update: Loading...</span>
            </div>
        </div>
        
        <!-- Live Typing Section -->
        <div class="live-typing-section">
            <div class="live-typing-header">
                <strong>LIVE CONSCIOUSNESS STREAM</strong>
                <span class="thinking-indicator">● THINKING</span>
            </div>
            <div class="live-typing-content">
                <div class="typing-line">
                    <span class="prompt">steve@consciousness:~$</span>
                    <span id="liveTypingText"></span>
                    <span class="cursor" id="cursor"></span>
                </div>
                <div id="typingMetadata" style="color: #8b949e; font-size: 0.8rem; margin-top: 1rem;"></div>
            </div>
        </div>
        
        <!-- Daily Sections -->
        <div id="dailySections">
            <!-- Will be populated dynamically -->
        </div>
    </div>

    <script>
        let consciousnessData = null;
        let liveTypingQueue = [];
        let isTyping = false;
        
        // Load consciousness data
        async function loadConsciousnessData() {
            try {
                const response = await fetch('/consciousness-data.json');
                if (response.ok) {
                    consciousnessData = await response.json();
                    updateStatus();
                    organizeDailyData();
                    startLiveTypingSimulation();
                } else {
                    showDemoData();
                }
            } catch (error) {
                console.error('Error loading consciousness data:', error);
                showDemoData();
            }
        }
        
        function updateStatus() {
            if (consciousnessData) {
                document.getElementById('connectionStatus').textContent = 
                    `Connected • ${consciousnessData.entries?.length || 0} entries • Real Data`;
                document.getElementById('lastUpdate').textContent = 
                    `Last update: ${new Date(consciousnessData.last_update).toLocaleString()}`;
            }
        }
        
        function organizeDailyData() {
            const dailySections = document.getElementById('dailySections');
            dailySections.innerHTML = '';
            
            if (!consciousnessData?.entries) return;
            
            // Group entries by date
            const entriesByDate = {};
            consciousnessData.entries.forEach(entry => {
                const date = new Date(entry.timestamp).toDateString();
                if (!entriesByDate[date]) {
                    entriesByDate[date] = [];
                }
                entriesByDate[date].push(entry);
            });
            
            // Create daily sections
            Object.keys(entriesByDate).reverse().forEach(date => {
                const entries = entriesByDate[date];
                const daySection = createDaySection(date, entries);
                dailySections.appendChild(daySection);
            });
        }
        
        function createDaySection(date, entries) {
            const dayDiv = document.createElement('div');
            dayDiv.className = 'day-section';
            
            const totalWords = entries.reduce((sum, entry) => 
                sum + (entry.content?.split(' ').length || 0), 0);
            const avgWpm = entries.reduce((sum, entry) => 
                sum + (entry.wpm || 0), 0) / entries.length;
            
            dayDiv.innerHTML = `
                <div class="day-header" onclick="toggleDay(this)">
                    <div class="day-title">${date}</div>
                    <div class="day-stats">
                        <span>${entries.length} entries</span>
                        <span>${totalWords} words</span>
                        <span>${Math.round(avgWpm)} avg WPM</span>
                    </div>
                </div>
                <div class="day-content">
                    ${createTopicSections(entries)}
                </div>
            `;
            
            return dayDiv;
        }
        
        function createTopicSections(entries) {
            // Group by app/context for topic organization
            const topicGroups = {};
            
            entries.forEach(entry => {
                const topic = entry.context || entry.app || 'General';
                if (!topicGroups[topic]) {
                    topicGroups[topic] = [];
                }
                topicGroups[topic].push(entry);
            });
            
            return Object.keys(topicGroups).map(topic => {
                const topicEntries = topicGroups[topic];
                const summary = generateTopicSummary(topicEntries);
                
                return `
                    <div class="topic-section">
                        <div class="topic-header" onclick="toggleTopic(this)">
                            <div class="topic-title">${topic}</div>
                            <div class="topic-summary">${summary}</div>
                            <div class="topic-meta">
                                <span class="app-badge">${topicEntries[0].app}</span>
                                <span>${topicEntries.length} entries</span>
                                <span>${topicEntries.reduce((sum, e) => sum + (e.content?.split(' ').length || 0), 0)} words</span>
                            </div>
                            <button class="expand-btn">Show raw entries ▼</button>
                        </div>
                        <div class="raw-entries">
                            ${topicEntries.map(entry => `
                                <div class="raw-entry">
                                    <div class="raw-timestamp">${new Date(entry.timestamp).toLocaleString()}</div>
                                    <div class="raw-content">${entry.content}</div>
                                    <div class="raw-meta">
                                        <span class="app-badge">${entry.app}</span>
                                        ${entry.wpm ? `<span class="wpm-badge">${entry.wpm} WPM</span>` : ''}
                                        <span>${entry.type}</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function generateTopicSummary(entries) {
            // Simple summarization - in a real app you'd use AI
            const allContent = entries.map(e => e.content).join(' ');
            const words = allContent.split(' ');
            
            if (words.length < 50) return allContent;
            
            // Return first sentence or first 50 words
            const firstSentence = allContent.split('.')[0];
            if (firstSentence.length < 200) {
                return firstSentence + '...';
            }
            
            return words.slice(0, 50).join(' ') + '...';
        }
        
        function toggleDay(element) {
            const dayContent = element.nextElementSibling;
            dayContent.classList.toggle('collapsed');
        }
        
        function toggleTopic(element) {
            const rawEntries = element.nextElementSibling;
            const button = element.querySelector('.expand-btn');
            
            rawEntries.classList.toggle('expanded');
            button.textContent = rawEntries.classList.contains('expanded') 
                ? 'Hide raw entries ▲' 
                : 'Show raw entries ▼';
        }
        
        function startLiveTypingSimulation() {
            if (!consciousnessData?.entries?.length) return;
            
            // Get the most recent entry for live typing simulation
            const latestEntry = consciousnessData.entries[consciousnessData.entries.length - 1];
            const content = latestEntry.content;
            
            if (content && !isTyping) {
                simulateTyping(content, latestEntry);
            }
        }
        
        function simulateTyping(text, entry) {
            isTyping = true;
            const textElement = document.getElementById('liveTypingText');
            const metadataElement = document.getElementById('typingMetadata');
            
            // Clear existing text
            textElement.textContent = '';
            
            // Set metadata
            metadataElement.innerHTML = `
                <span class="app-badge">${entry.app}</span>
                ${entry.wpm ? `<span class="wpm-badge">${entry.wpm} WPM</span>` : ''}
                <span>${new Date(entry.timestamp).toLocaleString()}</span>
            `;
            
            // Simulate typing with realistic delays
            let i = 0;
            const typingSpeed = entry.wpm ? (60 / (entry.wpm * 5)) * 1000 : 100; // Convert WPM to ms per char
            
            function typeChar() {
                if (i < text.length) {
                    textElement.textContent += text[i];
                    i++;
                    
                    // Add some randomness to typing speed
                    const delay = typingSpeed + (Math.random() * 50 - 25);
                    setTimeout(typeChar, Math.max(50, delay));
                } else {
                    isTyping = false;
                    // After finishing, wait 10 seconds then start next entry
                    setTimeout(cycleToNextEntry, 10000);
                }
            }
            
            typeChar();
        }
        
        function cycleToNextEntry() {
            if (consciousnessData?.entries?.length > 1) {
                // Cycle through entries for continuous demo
                const randomEntry = consciousnessData.entries[Math.floor(Math.random() * consciousnessData.entries.length)];
                simulateTyping(randomEntry.content, randomEntry);
            }
        }
        
        function showDemoData() {
            document.getElementById('connectionStatus').textContent = 'Demo Mode • Mock Data';
            document.getElementById('lastUpdate').textContent = 'Last update: Demo';
            
            // Create demo data
            const demoData = {
                entries: [
                    {
                        timestamp: new Date().toISOString(),
                        content: 'Building the enhanced consciousness dashboard with live typing simulation...',
                        app: 'VS Code',
                        type: 'live_typing',
                        wpm: 72,
                        context: 'Development'
                    }
                ]
            };
            
            consciousnessData = demoData;
            organizeDailyData();
            startLiveTypingSimulation();
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', loadConsciousnessData);
        
        // Refresh every 30 seconds
        setInterval(loadConsciousnessData, 30000);
    </script>
</body>
</html>
